/// # 递归实现指数型枚举
///
/// ## 题目描述
///
/// 从 1~n 这 n 个整数中随机选取任意多个, 每种方案里的数从小到大, 按字典序输出所有可能的选择方案
///
/// ## 输入
///
/// 输入一个整数 n
///
/// ## 输出
///
/// 每一组的方案, 每组方案中两个数之间用空格分割.
///
/// 注意每一行最后一个数没有空格.
///
/// ## 样例输入
///
/// ```
/// 3
/// ```
///
/// ## 样例输出
///
/// ```
/// 1
/// 1 2
/// 1 2 3
/// 1 3
/// 2
/// 2 3
/// 3
/// ```
///
/// ## 样例输入
///
/// ```
/// 4
/// ```
///
/// ## 样例输出
///
/// ```
/// 1
/// 1 2
/// 1 2 3
/// 1 2 3 4
/// 1 3 4
/// 1 4
/// 2
/// 2 3
/// 2 3 4
/// 2 4
/// 3 4
/// 4
/// ```
///
fn main() {
    let mut arr: Vec<usize> = vec![0; 10];

    println!("input: {}", 3);
    println!("output:");
    f(0, 1, 3, &mut arr);

    println!("input: {}", 4);
    println!("output:");
    f(0, 1, 4, &mut arr);
}

/// ## 1.
/// i: 代表当前位置,
/// j: 代表当前可选最小数字,
/// n: 代表当前可选最大数字,
/// ## 2.
/// if j > n; return
/// ## 3.
/// f(i,j,n) => j + f(i+1, j+1, n) => j + 1 + f(i, j+2, n)
/// => ... => n + f(i+1, n+1, n)
fn f(i: usize, j: usize, n: usize, arr: &mut Vec<usize>) {
    if j > n {
        return;
    }
    for k in j..=n {
        arr[i] = k;
        print_one_result(i, arr);
        f(i+1, k+1, n, arr);
    }
}

fn print_one_result(n: usize, arr: &Vec<usize>) {
    for i in 0..=n {
        print!("{} ", arr[i])
    }
    println!()
}
